/*!
 * duckfficer v2.2.4
 * (c) 2019-2021 Martin Rafael <tin@devtin.io>
 * MIT
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("events")):"function"==typeof define&&define.amd?define(["exports","events"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).default=t.default||{},t.events)}(this,(function(t,e){"use strict";function r(t){return Array.isArray(t)?t:[t]}function s(t,{parent:e="",separator:r="."}={}){const a=[];return Object.keys(t).forEach((i=>{if(t[i]&&"object"==typeof t[i]&&!Array.isArray(t[i]))return a.push(...s(t[i],{parent:`${e}${i}${r}`,separator:r}));a.push(`${e}${i}`)})),a}function a(t,e){const[r,...s]=Array.isArray(e)?e:e.split(".");return s.length>0&&"object"==typeof t[r]?a(t[r],s):r?t[r]:t}function i(t,e){for(let r=0;r<t.length&&!1!==e(t[r],r);r++);}function n(t){return t.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")}function o(t,e){return s(e).forEach((r=>{t=t.replace(new RegExp(`{[\\s]*${r.split(".").map(n).join(".")}[\\s]*}`,"g"),a(e,r))})),t}function h(t){return"object"==typeof t&&!Array.isArray(t)&&null!==t}function c(t,e,{strict:r=!1}={}){if(!h(t))return!1;let s=!0;return r&&i(e,(a=>{if(a.indexOf(".")>0){const[i]=a.split(".");return s=c(t[i],function(t,e){e=e.split(".").map(n).join(".");const r=new RegExp(`^${e}\\.`);return t.filter((t=>r.test(t))).map((t=>t.replace(r,"")))}(e,i),{strict:r}),s}if(!Object.prototype.hasOwnProperty.call(t,a))return s=!1,s})),s&&i(Object.keys(t),(r=>{if("object"==typeof t[r]&&!Array.isArray(t[r])){const a=new RegExp(`^${n(r)}\\.(.+)$`);let i=e.indexOf(r)>=0;const o=e.filter((t=>a.test(t))).map((t=>(i=!1,t.replace(a,"$1"))));return s=i||c(t[r],o),s}if(-1===e.indexOf(r))return s=!1,s})),s}const l=async function(t,e,r=!1){for(const s of t)if(!1===await e(s)&&r)break},u=async function(t,e,r){const s=[];let a=0;return await l(t,(async t=>{s.push(await e(t,a++))}),r),s};var p=Object.freeze({__proto__:null,castArray:r,obj2dot:s,find:a,forEach:i,render:o,propertiesRestricted:c,PromiseEach:l,PromiseMap:u});function d(t,e){return Array.isArray(t)&&2===t.length?t:[t,e]}const g={Array:{settings:{typeError:"Invalid array"},async parse(t){return this.settings.arraySchema?u(t,((t,e)=>{const{constructor:r}=this,s=r.castSchema(this.settings.arraySchema);return(()=>"Schema"===r.guessType(s)?r.cloneSchema({schema:s,name:e,parent:this,settings:s.settings}):new this.constructor(this.settings.arraySchema,Object.assign({},this.settings.arraySchema,{name:e,parent:this})))().parse(t)})):t},validate(t){Array.isArray(t)||this.throwError(this.settings.typeError,{value:t})}},BigInt:{settings:{typeError:"Invalid bigint",autoCast:!1},validate(t){"bigint"!=typeof t&&this.throwError(this.settings.typeError)},cast(t){if(/^(string|number)$/.test(typeof t))try{t=BigInt(t)}catch(t){}return t}},Boolean:{settings:{typeError:"Invalid boolean",autoCast:!1},cast:t=>!!t,validate(t){"boolean"!=typeof t&&this.throwError(this.settings.typeError,{value:t})}},Date:{settings:{typeError:"Invalid date",autoCast:!0},cast(t){if(t instanceof Date)return t;const e=new Date(Number.isInteger(t)?t:Date.parse(t));return"Invalid Date"!==e.toString()&&(t=e),t},validate(t){t instanceof Date||this.throwError(this.settings.typeError,{value:t})}},Function:{settings:{typeError:"Invalid function"},validate(t){"function"!=typeof t&&this.throwError(this.settings.typeError,{value:t})}},Map:{settings:{typeError:"Invalid map",autoCast:!0},cast:t=>(!h(t)||t instanceof Map||(t=new Map(Object.entries(t))),t),validate(t){t instanceof Map||this.throwError(this.settings.typeError,{value:t})}},Number:{settings:{typeError:"Invalid number",minError:"minimum accepted value is { value }",maxError:"maximum accepted value is { value }",integerError:"Invalid integer",min:void 0,max:void 0,integer:!1,decimalPlaces:void 0,autoCast:!1},cast(t){if("number"!=typeof t){const e=Number(t);if(!isNaN(e))return e}return t},validate(t){("number"!=typeof t||isNaN(t))&&this.throwError(this.settings.typeError,{value:t}),this.settings.integer&&!Number.isInteger(t)&&this.throwError(this.settings.integerError,{value:t}),void 0!==this.settings.min&&t<this.settings.min&&this.throwError(this.settings.minError,{value:this.settings.min}),void 0!==this.settings.max&&t>this.settings.max&&this.throwError(this.settings.maxError,{value:this.settings.max})},parse(t){if(void 0!==this.settings.decimalPlaces){const e=Math.pow(10,this.settings.decimalPlaces);return Math.round(t*e)/e}return t}},Object:{settings:{typeError:"Invalid object"},async parse(t){if(void 0!==this.settings.mapSchema){const e={};return await l(Object.keys(t),(async r=>{const s=t[r],a=this.constructor.castSchema(this.settings.mapSchema),i="Schema"===this.constructor.guessType(a)?this.constructor.cloneSchema({schema:a,name:r,settings:a.settings,parent:this}):t[r]=new this.constructor(this.settings.mapSchema,Object.assign({},this.settings.mapSchema,{name:r,parent:this}));e[r]=await i.parse(s)})),e}return t},validate(t){h(t)||this.throwError(this.settings.typeError,{value:t})}},Set:{settings:{typeError:"Invalid set",autoCast:!0},cast:t=>(Array.isArray(t)&&(t=new Set(t)),t),validate(t){t instanceof Set||this.throwError(this.settings.typeError,{value:t})}},String:{settings:{typeError:"Invalid string",emptyError:"Value can not be empty",enumError:"Unknown enum option { value }",enum:[],autoCast:!1,allowEmpty:!0,lowercase:!1,uppercase:!1},cast:t=>(t&&Object.hasOwnProperty.call(t,"toString")&&"function"==typeof t.toString&&"[object Object]"!==t.toString()&&(t=t.toString()),t),validate(t){if("string"!=typeof t&&this.throwError(this.settings.typeError,{value:t}),Array.isArray(this.settings.enum)&&this.settings.enum.length>0&&this.settings.enum.indexOf(t)<0&&this.throwError(this.settings.enumError,{value:t}),!this.settings.allowEmpty&&/^[\s]*$/ms.test(t)&&this.throwError(this.settings.emptyError,{value:t}),this.settings.minlength){const[e,r]=d(this.settings.minlength,"Invalid minlength");t.length<e&&this.throwError(r,{value:t})}if(this.settings.maxlength){const[e,r]=d(this.settings.maxlength,"Invalid maxlength");t.length>e&&this.throwError(r,{value:t})}if(this.settings.regex){const[e,r]=d(this.settings.regex,"Invalid regex");e.test(t)||this.throwError(r,{value:t})}},parse(t){return this.settings.lowercase&&(t=t.toLowerCase()),this.settings.uppercase&&(t=t.toUpperCase()),t}}};class y extends Error{constructor(t,{errors:e=[],value:r,field:s}){super(o(t,{errors:e,value:r,field:s})),this.errors=e,this.value=r,this.field=s}toJSON(){const{message:t,value:e,field:r,errors:s}=this;return{message:t,value:e,errors:s?s.map(y.prototype.toJSON.call):void 0,field:r?r.fullPath:r}}}class f extends Error{constructor(t,e){super(t),this.errorName=t,this.payload=e}}const m=async t=>Promise.resolve(t);class v{constructor(t,{name:e="",defaultValues:r={},methods:s={},parent:a,validate:i,cast:n,settings:o={}}={}){if(this._settings=o,Array.isArray(t)&&1===t.length&&(t=t[0]),this._methods=s,this.schema=t,this.parent=a,this._validate=i,this._cast=n,this.name=e,this.originalName=this.name,this.type=v.guessType(t),this.resetCurrentType(),this.children=[],this._defaultSettings={required:!0,allowNull:!1,default:void 0},this._defaultValues=r,this.virtuals=[],v.isNested(t)?this.children=this._parseSchema(t):(this._settings="object"==typeof t?Object.assign({},this._settings,{required:void 0===t.default},t):this._settings,delete this._settings.type),void 0!==this.settings.default&&this.settings.required)throw new Error(`Remove either the 'required' or the 'default' option for property ${this.fullPath}.`);this._defaultSettings.default=this.getDefault()}resetCurrentType(){this.currentType=r(this.type)[0]}get hasChildren(){return this.children.length>0}get validate(){return this._validate||m}get cast(){return this._cast||m}get settings(){return!this.hasChildren&&g[this.currentType]&&g[this.currentType].settings?Object.assign(this._defaultSettings,g[this.currentType].settings,this._settings):Object.assign(this._defaultSettings,this._settings)}static castSchema(t){return t instanceof v?t:"object"==typeof t&&"Schema"===v.guessType(t.type)?t.type:t}static castSettings(t){if(t instanceof v)return t.settings;const e=Object.assign({},t);return delete e.type,e}async isValid(t){try{return await this.parse(t),!0}catch(t){return!1}}_parseSchema(t){return Object.keys(t).map((e=>{const r=Object.getOwnPropertyDescriptor(t,e);if("function"!=typeof r.get&&"function"!=typeof r.set)return"Schema"===v.guessType(t[e])?v.cloneSchema({schema:v.castSchema(t[e]),settings:v.castSettings(t[e]),name:e,parent:this}):new v(t[e],{name:e,parent:this});this.virtuals.push({path:e,getter:r.get,setter:r.set})})).filter(Boolean)}static isNested(t){return"Object"===v.guessType(t)&&!t.type}static guessType(t){return t instanceof v?"Schema":"function"==typeof t?t.name:"object"==typeof t&&t.type?v.guessType(t.type):"object"!=typeof t||Array.isArray(t)?(Array.isArray(t)&&(t=t.map(v.guessType)),t):"Object"}get fullPath(){return(this.parent&&this.parent.fullPath?`${this.parent.fullPath}.`:"")+this.name}get ownPaths(){return this.children.map((({name:t})=>t))}get paths(){const t=[];return this.name&&t.push(this.name),this.hasChildren&&this.children.forEach((({paths:e})=>{e.forEach((e=>{t.push((this.name?`${this.name}.`:"")+e)}))})),t}static cloneSchema({schema:t,name:e,parent:r,settings:s={},defaultValues:a,type:i,cast:n,validate:o,currentType:h}){const c=Object.assign(Object.create(Object.getPrototypeOf(t)),t,{name:void 0!==e?e:t.name,type:i||t.type,currentType:h||t.currentType,_cast:n||!1===n?n:t._cast,_validate:o||!1===o?o:t._validate,parent:r,cloned:!0,_defaultValues:a||t._defaultValues,_settings:Object.assign({},t._settings,s)});return c.children&&(c.children=c.children.map((t=>v.cloneSchema({schema:t,parent:c})))),c}schemaAtPath(t){const[e,r]=t.split(/\./);let s;return i(this.children,(t=>{if(t.name===e)return s=t,!1})),r?s.schemaAtPath(r):s}hasField(t,e=!1){return this.paths.indexOf(e?t:t.replace(/\..*$/,""))>=0}structureValidation(t){if(!h(t)||!this.hasChildren)return;const e=[];if(c(t,this.ownPaths)||t&&s(t).forEach((t=>{this.hasChildren&&!this.hasField(t)&&e.push(new Error(`Unknown property ${this.name?this.name+".":""}${t}`))})),this.ownPaths.forEach((r=>{try{this.schemaAtPath(r).structureValidation(t[r])}catch(t){const{errors:r}=t;e.push(...r)}})),e.length>0)throw new y("Invalid object schema"+(this.parent?` in property ${this.fullPath}`:""),{errors:e,value:t,field:this})}async fullCast(t,{state:e}){return"object"==typeof(t=await this.cast(t,{state:e}))&&t&&this.hasChildren&&await l(this.children,(async r=>{const s=await r.fullCast(t[r.name],{state:e});void 0!==s&&(t[r.name]=s)})),t}static ensureSchema(t){return t instanceof v?t:new v(t)}async parse(t,{state:r={},virtualsEnumerable:s=!1}={}){if(t=await this.fullCast(t,{state:r}),this.parent||this.structureValidation(t),t=this.hasChildren?await this.runChildren(t,{state:r}):await this.parseProperty(this.type,t,{state:r}),await this.validate(t,{state:r}),h(t)&&this.virtuals.forEach((({path:e,getter:r,setter:a})=>{Object.defineProperties(t,{[e]:{get:r,set:a,enumerable:s}})})),h(t)||Array.isArray(t)){const r=new e.EventEmitter;Object.defineProperties(t,{$on:{value:r.on.bind(r),writable:!0,enumerable:!1}}),Object.keys(this._methods).forEach((e=>{const s=this._methods[e].input,a=this._methods[e].output,i=this._methods[e].enumerable,n=this._methods[e].events,o=this._methods[e].errors;Object.defineProperty(t,e,{value:async(...i)=>{if(s)try{i[0]=await v.ensureSchema(s).parse(i[0])}catch(t){throw new y(`Invalid input at method ${e}`,{errors:t.errors.length>0?t.errors:[t],value:i[0]})}const h={async $emit(t,e){if(n){if(!n[t])throw new Error(`Unknown event ${t}`);try{e=await v.ensureSchema(n[t]).parse(e)}catch(e){throw new y(`Invalid payload for event ${t}`,{errors:e.errors.length>0?e.errors:[e]})}}r.emit(t,e)},async $throw(t,e){if(o){if(!o[t])throw new f(`Unknown error ${t}`);try{e=o[t]?await v.ensureSchema(o[t]).parse(e):e}catch(e){throw new y(`Invalid payload for error ${t}`,{errors:e.errors.length>0?e.errors:[e]})}}throw new f(t,e)},$field:t},c=await(this._methods[e].handler||this._methods[e]).apply(h,i);if(a)try{return await v.ensureSchema(a).parse(c)}catch(t){throw new y(`Invalid output at method ${e}`,{errors:t.errors.length>0?t.errors:[t]})}return c},writable:!0,enumerable:i})}))}return t}async processLoaders(t,{loaders:e,state:s}){return await l(r(e),(async e=>{"object"!=typeof e&&(e={type:e});const r=v.guessType(e),a=v.cloneSchema({schema:this,type:r,currentType:r,cast:!1,validate:!1});"Schema"!==r&&(a._settings=Object.assign({},a._settings,{loaders:void 0,cast:void 0,validate:void 0},e)),t=await a.parseProperty(r,t,{state:s})})),t}async parseProperty(t,e,{state:r={}}={}){if(null===e&&this.settings.allowNull)return e;if(Array.isArray(t)){let s,a=!1;return await l(t,(async t=>{try{return this.currentType=t,s=await this.parseProperty(t,e,{state:r}),a=!0,!1}catch(t){}}),!0),this.resetCurrentType(),a||this.throwError(`Could not resolve given value type${this.fullPath?" in property "+this.fullPath:""}. Allowed types are ${t.slice(0,-1).join(", ")+" and "+t[t.length-1]}`,{value:e}),s}const s=g[t];if(s||this.throwError(`Don't know how to resolve ${t} in property ${this.fullPath}`,{value:e}),void 0!==this.settings.default&&void 0===e&&(e="function"==typeof this.settings.default?await this.settings.default.call(this,{state:r}):this.settings.default),this.settings.loaders&&(e=await this.processLoaders(e,{loaders:this.settings.loaders,state:r})),s.loaders&&(e=await this.processLoaders(e,{loaders:s.loaders,state:r})),e=await this.runTransformer({method:"cast",transformer:this.settings,payload:e,state:r}),this.settings.autoCast&&(e=await this.runTransformer({method:"cast",transformer:s,payload:e,state:r})),void 0!==e||this.settings.required){if(void 0===e&&this.settings.required){const[t,r]=d(this.settings.required,`Property ${this.fullPath} is required`);t&&this.throwError(r,{value:e})}return await this.runTransformer({method:"validate",transformer:s,payload:e,state:r}),await this.runTransformer({method:"validate",transformer:this.settings,payload:e,state:r}),this.runTransformer({method:"parse",transformer:s,payload:e,state:r})}}async runChildren(t,{method:e="parse",state:r={}}={}){if(!this.settings.required&&void 0===t)return;const s={},a=[];if(await l(this.ownPaths,(async i=>{const n=this.schemaAtPath(i.replace(/\..*$/)),o=h(t)?t[n.name]:void 0;await(async t=>{try{await t()}catch(t){t instanceof y&&t instanceof y&&t.errors.length>0?a.push(...t.errors):a.push(t)}})((async()=>{const t=await n[e](o,{state:r});void 0!==t&&Object.assign(s,{[n.name]:t})}))})),a.length>0)throw new y("Data is not valid",{errors:a});return s}runTransformer({method:t,transformer:e,payload:r,state:s}){return e[t]?e[t].call(this,r,{state:s}):r}throwError(t,{errors:e,value:r}={}){throw this.resetCurrentType(),new y(t,{errors:e,value:r,field:this})}getDefault(t){return this.parent?this.parent.getDefault(t?`${this.name}.${t}`:this.name):t?a(this._defaultValues,t):void 0}}t.Schema=v,t.Transformers=g,t.Utils=p,t.ValidationError=y,Object.defineProperty(t,"__esModule",{value:!0})}));

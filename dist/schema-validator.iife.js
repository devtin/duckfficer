/*!
 * @devtin/schema-validator v2.8.0
 * (c) 2019-2020 Martin Rafael Gonzalez <tin@devtin.io>
 * MIT
 */
var SchemaValidator=function(a){'use strict';function b(a){return Array.isArray(a)?a:[a]}function c(a,{parent:b="",separator:d="."}={}){const e=[];return Object.keys(a).forEach(f=>a[f]&&"object"==typeof a[f]&&!Array.isArray(a[f])?e.push(...c(a[f],{parent:`${b}${f}${d}`,separator:d})):void e.push(`${b}${f}`)),e}function d(a,b){const[c,...e]=Array.isArray(b)?b:b.split(".");return 0<e.length&&"object"==typeof a[c]?d(a[c],e):c?a[c]:a}function e(a,b){for(let c=0;c<a.length&&!1!==b(a[c],c);c++);}function f(a){return a.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")}function g(a,b){const e=c(b);return e.forEach(c=>{a=a.replace(new RegExp(`{[\\s]*${c.split(".").map(f).join(".")}[\\s]*}`,"g"),d(b,c))}),a}function h(a,b){b=b.split(".").map(f).join(".");const c=new RegExp(`^${b}\\.`);return a.filter(a=>c.test(a)).map(a=>a.replace(c,""))}function i(a,b,{strict:c=!1}={}){if("object"!=typeof a)return!1;let d=!0;return c&&e(b,e=>{if(0<e.indexOf(".")){const[f]=e.split(".");return d=i(a[f],h(b,f),{strict:c})}return Object.prototype.hasOwnProperty.call(a,e)?void 0:d=!1}),d&&e(Object.keys(a),c=>{if("object"==typeof a[c]&&!Array.isArray(a[c])){const e=new RegExp(`^${f(c)}\\.(.+)$`);let g=0<=b.indexOf(c);const h=b.filter(a=>e.test(a)).map(a=>(g=!1,a.replace(e,"$1")));return d=g||i(a[c],h)}return-1===b.indexOf(c)?d=!1:void 0}),d}function j(a,b){return Array.isArray(a)&&2===a.length?a:[a,b]}var k=Object.freeze({__proto__:null,castArray:b,obj2dot:c,find:d,forEach:e,render:g,propertiesRestricted:i});const l={Array:{settings:{typeError:`Invalid array`},parse(a){return this.settings.arraySchema&&(a=a.map((a,b)=>{const c=this.constructor.castSchema(this.settings.arraySchema),d="Schema"===this.constructor.guessType(c)?this.constructor.cloneSchema({schema:c,name:b,parent:this,settings:c.settings}):new this.constructor(this.settings.arraySchema,Object.assign({},this.settings.arraySchema,{name:b,parent:this}));return d.parse(a)})),a},validate(a){Array.isArray(a)||this.throwError(l.Array.settings.typeError,{value:a})}},BigInt:{settings:{typeError:"Invalid bigint",autoCast:!1},validate(a){"bigint"!=typeof a&&this.throwError(l.BigInt.settings.typeError)},cast(a){if(/^(string|number)$/.test(typeof a))try{a=BigInt(a)}catch(a){}return a}},Boolean:{settings:{typeError:`Invalid boolean`,autoCast:!1},cast(a){return!!a},validate(a){"boolean"!=typeof a&&this.throwError(l.Boolean.settings.typeError,{value:a})}},Date:{settings:{typeError:`Invalid date`,autoCast:!0},cast(a){var b=Number.isInteger;if(a instanceof Date)return a;const c=new Date(b(a)?a:Date.parse(a));return"Invalid Date"!==c.toString()&&(a=c),a},validate(a){a instanceof Date||this.throwError(l.Date.settings.typeError,{value:a})}},Function:{settings:{typeError:`Invalid function`},validate(a){"function"!=typeof a&&this.throwError(l.Function.settings.typeError,{value:a})}},Number:{settings:{typeError:`Invalid number`,autoCast:!1},cast(a){return+a},validate(a){("number"!=typeof a||isNaN(a))&&this.throwError(l.Number.settings.typeError,{value:a})}},Object:{settings:{typeError:`Invalid object`},parse(a){return void 0!==this.settings.mapSchema&&Object.keys(a).forEach(b=>{const c=a[b],d=this.constructor.castSchema(this.settings.mapSchema),e="Schema"===this.constructor.guessType(d)?this.constructor.cloneSchema({schema:d,name:b,settings:d.settings,parent:this}):a[b]=new this.constructor(this.settings.mapSchema,Object.assign({},this.settings.mapSchema,{name:b,parent:this}));a[b]=e.parse(c)}),a},validate(a){"object"!=typeof a&&this.throwError(l.Object.settings.typeError,{value:a})}},Promise:{settings:{typeError:`Invalid Promise`,autoCast:!1,isPromise(a){return"object"==typeof a&&"function"==typeof a.then}},cast(a){return l.Promise.settings.isPromise(a)?a:"function"==typeof a?Promise.resolve(a()):Promise.resolve(a)},validate(a){l.Promise.settings.isPromise(a)||this.throwError(l.Promise.settings.typeError,{value:a})}},Set:{settings:{typeError:`Invalid set`,autoCast:!0},cast(a){return Array.isArray(a)&&(a=new Set(a)),a},validate(a){a instanceof Set||this.throwError(l.Set.settings.typeError,{value:a})}},String:{settings:{typeError:`Invalid string`,enumError:`Unknown enum option { value }`,enum:[],autoCast:!1},cast(a){return a&&Object.hasOwnProperty.call(a,"toString")&&"function"==typeof a.toString&&"[object Object]"!==a.toString()&&(a=a.toString()),a},validate(a){if("string"!=typeof a&&this.throwError(l.String.settings.typeError,{value:a}),Array.isArray(this.settings.enum)&&0<this.settings.enum.length&&0>this.settings.enum.indexOf(a)&&this.throwError(l.String.settings.enumError,{value:a}),this.settings.minlength){const[b,c]=j(this.settings.minlength,`Invalid minlength`);a.length<b&&this.throwError(c,{value:a})}if(this.settings.maxlength){const[b,c]=j(this.settings.maxlength,`Invalid maxlength`);a.length>b&&this.throwError(c,{value:a})}if(this.settings.regex){const[b,c]=j(this.settings.regex,`Invalid regex`);b.test(a)||this.throwError(c,{value:a})}}}};class m extends Error{constructor(a,{errors:d=[],value:b,field:c}){super(g(a,{errors:d,value:b,field:c})),this.errors=d,this.value=b,this.field=c}toJSON(){const{message:a,value:b}=this,c={message:a,value:b};return this.field&&Object.assign(c,{field:this.field.fullPath}),c}}const n=a=>a;class o{constructor(a,{name:c,defaultValues:g={},parent:d,validate:e,cast:f,settings:h={}}={}){if(this._settings=h,Array.isArray(a)&&1===a.length&&(a=a[0]),this.schema=a,this.parent=d,this._validate=e,this._cast=f,this.name=c||"",this.originalName=this.name,this.type=o.guessType(a),this.currentType=b(this.type)[0],this.children=[],this._defaultSettings={required:!0,allowNull:!1,default:void 0},this._defaultValues=g,o.isNested(a)?this.children=this._parseSchema(a):(this._settings="object"==typeof a?Object.assign({},this._settings,{required:void 0===a.default},a):this._settings,delete this._settings.type),void 0!==this.settings.default&&this.settings.required)throw new Error(`Remove either the 'required' or the 'default' option for property ${this.fullPath}.`);this._defaultSettings.default=this.getDefault()}get hasChildren(){return 0<this.children.length}get validate(){return this._validate||n}get cast(){return this._cast||n}get settings(){return!this.hasChildren&&l[this.currentType]&&l[this.currentType].settings?Object.assign(this._defaultSettings,l[this.currentType].settings,this._settings):Object.assign(this._defaultSettings,this._settings)}static castSchema(a){return a instanceof o?a:"object"==typeof a&&"Schema"===o.guessType(a.type)?a.type:a}static castSettings(a){if(a instanceof o)return a.settings;const b=Object.assign({},a);return delete b.type,b}_parseSchema(a){return Object.keys(a).map(b=>{if("Schema"===o.guessType(a[b])){const c=o.cloneSchema({schema:o.castSchema(a[b]),settings:o.castSettings(a[b]),name:b,parent:this});return c}return new o(a[b],{name:b,parent:this})})}static isNested(a){return"Object"===o.guessType(a)&&!a.type}static guessType(a){return a instanceof o?"Schema":"function"==typeof a?a.name:"object"==typeof a&&a.type?o.guessType(a.type):"object"!=typeof a||Array.isArray(a)?(Array.isArray(a)&&(a=a.map(o.guessType)),a):"Object"}get fullPath(){return(this.parent&&this.parent.fullPath?`${this.parent.fullPath}.`:"")+this.name}get ownPaths(){return this.children.map(({name:a})=>a)}get paths(){const a=[];return this.hasChildren?this.children.forEach(({paths:b})=>{b.forEach(b=>{a.push((this.name?`${this.name}.`:"")+b)})}):a.push(this.name),a}static cloneSchema({schema:a,name:b,parent:c,settings:e={},defaultValues:d}){const f=Object.assign(Object.create(Object.getPrototypeOf(a)),a,{name:b||a.name,parent:c,cloned:!0,_defaultValues:d||a._defaulValues,_settings:Object.assign({},a._settings,e)});return f.children&&(f.children=f.children.map(a=>o.cloneSchema({schema:a,parent:f}))),f}schemaAtPath(a){const[b,c]=a.split(/\./);let d;return e(this.children,a=>{if(a.name===b)return d=a,!1}),c?d.schemaAtPath(c):d}hasField(a,b=!1){return 0<=this.paths.indexOf(b?a:a.replace(/\..*$/,""))}structureValidation(a){if(!a||!this.hasChildren)return!0;if(!i(a,this.ownPaths)){const b=[];throw a&&c(a).forEach(a=>{this.hasField(a)||b.push(new Error(`Unknown property ${a}`))}),new m(`Invalid object schema`+(this.parent?` in property ${this.fullPath}`:""),{errors:b,value:a,field:this})}}parse(a,{state:b={}}={}){return a=this.cast.call(this,a,{state:b}),a=this.hasChildren?this.runChildren(a,{state:b}):this.parseProperty(this.type,a,{state:b}),this.validate.call(this,a,{state:b}),a}processLoaders(a,{loaders:c,state:d}){return e(b(c),b=>{"object"!=typeof b&&(b={type:b});const c=o.guessType(b),e=Object.assign(Object.create(this),this,{type:c,_cast:void 0,_validate:void 0});"Schema"!==c&&(e._settings=Object.assign({},e._settings,b,{loaders:void 0,cast:void 0,validate:void 0})),a=e.parseProperty(c,a,{state:d})}),a}parseProperty(a,b,{state:c={}}={}){if(null===b&&this.settings.allowNull)return b;if(Array.isArray(a)){let d,f=!1;return e(a,a=>{try{return this.currentType=a,d=this.parseProperty(a,b,{state:c}),f=!0,!1}catch(a){}}),f||this.throwError(`Could not resolve given value type in property ${this.fullPath}. Allowed types are ${a.slice(0,-1).join(", ")+" and "+a.pop()}`,{value:b}),d}const d=l[a];if(d||this.throwError(`Don't know how to resolve ${a} in property ${this.fullPath}`,{value:b}),void 0!==this.settings.default&&void 0===b&&(b="function"==typeof this.settings.default?this.settings.default.call(this,{state:c}):this.settings.default),void 0!==b||this.settings.required){if(void 0===b&&this.settings.required){const[a,c]=j(this.settings.required,`Property ${this.fullPath} is required`);a&&this.throwError(c,{value:b})}return this.settings.loaders&&(b=this.processLoaders(b,{loaders:this.settings.loaders,state:c})),d.loaders&&(b=this.processLoaders(b,{loaders:d.loaders,state:c})),b=this.runTransformer({method:"cast",transformer:this.settings,payload:b,state:c}),this.settings.autoCast&&(b=this.runTransformer({method:"cast",transformer:d,payload:b,state:c})),this.runTransformer({method:"validate",transformer:d,payload:b,state:c}),this.runTransformer({method:"validate",transformer:this.settings,payload:b,state:c}),this.runTransformer({method:"parse",transformer:d,payload:b,state:c})}}runChildren(a,{method:b="parse",state:c={}}={}){if(!this.settings.required&&void 0===a)return;const d={},e=[],f=a=>{try{a()}catch(a){a instanceof m?a instanceof m&&0<a.errors.length?e.push(...a.errors):e.push(a):e.push(a)}};if(f(()=>this.structureValidation(a)),this.ownPaths.forEach(e=>{const g=this.schemaAtPath(e.replace(/\..*$/)),h="object"==typeof a&&null!==a?a[g.name]:void 0;f(()=>{const a=g[b]?g[b](h,{state:c}):void 0;void 0!==a&&Object.assign(d,{[g.name]:a})})}),0<e.length)throw new m(`Data is not valid`,{errors:e});return d}runTransformer({method:a,transformer:b,payload:c,state:d={}}){return b[a]?b[a].call(this,c,{state:d}):c}throwError(a,{errors:b,value:c}={}){throw new m(a,{errors:b,value:c,field:this})}getDefault(a){return this.parent?this.parent.getDefault(a?`${this.name}.${a}`:this.name):a?d(this._defaultValues,a):void 0}}return a.Schema=o,a.Transformers=l,a.Utils=k,a.ValidationError=m,a}({});

/*!
 * @devtin/schema-validator v3.2.0
 * (c) 2019-2020 Martin Rafael <tin@devtin.io>
 * MIT
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).default=t.default||{})}(this,(function(t){"use strict";function e(t){return Array.isArray(t)?t:[t]}function s(t,{parent:e="",separator:r="."}={}){const i=[];return Object.keys(t).forEach(a=>{if(t[a]&&"object"==typeof t[a]&&!Array.isArray(t[a]))return i.push(...s(t[a],{parent:`${e}${a}${r}`,separator:r}));i.push(`${e}${a}`)}),i}function r(t,e){const[s,...i]=Array.isArray(e)?e:e.split(".");return i.length>0&&"object"==typeof t[s]?r(t[s],i):s?t[s]:t}function i(t,e){for(let s=0;s<t.length&&!1!==e(t[s],s);s++);}function a(t){return t.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&")}function n(t,e){return s(e).forEach(s=>{t=t.replace(new RegExp(`{[\\s]*${s.split(".").map(a).join(".")}[\\s]*}`,"g"),r(e,s))}),t}function o(t){return"object"==typeof t&&!Array.isArray(t)&&null!==t}function h(t,e,{strict:s=!1}={}){if(!o(t))return!1;let r=!0;return s&&i(e,i=>{if(i.indexOf(".")>0){const[n]=i.split(".");return r=h(t[n],function(t,e){e=e.split(".").map(a).join(".");const s=new RegExp(`^${e}\\.`);return t.filter(t=>s.test(t)).map(t=>t.replace(s,""))}(e,n),{strict:s}),r}if(!Object.prototype.hasOwnProperty.call(t,i))return r=!1,r}),r&&i(Object.keys(t),s=>{if("object"==typeof t[s]&&!Array.isArray(t[s])){const i=new RegExp(`^${a(s)}\\.(.+)$`);let n=e.indexOf(s)>=0;const o=e.filter(t=>i.test(t)).map(t=>(n=!1,t.replace(i,"$1")));return r=n||h(t[s],o),r}if(-1===e.indexOf(s))return r=!1,r}),r}var l=Object.freeze({__proto__:null,castArray:e,obj2dot:s,find:r,forEach:i,render:n,propertiesRestricted:h});function c(t,e){return Array.isArray(t)&&2===t.length?t:[t,e]}const u={Array:{settings:{typeError:"Invalid array"},parse(t){return this.settings.arraySchema&&(t=t.map((t,e)=>{const s=this.constructor.castSchema(this.settings.arraySchema);return("Schema"===this.constructor.guessType(s)?this.constructor.cloneSchema({schema:s,name:e,parent:this,settings:s.settings}):new this.constructor(this.settings.arraySchema,Object.assign({},this.settings.arraySchema,{name:e,parent:this}))).parse(t)})),t},validate(t){Array.isArray(t)||this.throwError(u.Array.settings.typeError,{value:t})}},BigInt:{settings:{typeError:"Invalid bigint",autoCast:!1},validate(t){"bigint"!=typeof t&&this.throwError(u.BigInt.settings.typeError)},cast(t){if(/^(string|number)$/.test(typeof t))try{t=BigInt(t)}catch(t){}return t}},Boolean:{settings:{typeError:"Invalid boolean",autoCast:!1},cast:t=>!!t,validate(t){"boolean"!=typeof t&&this.throwError(u.Boolean.settings.typeError,{value:t})}},Date:{settings:{typeError:"Invalid date",autoCast:!0},cast(t){if(t instanceof Date)return t;const e=new Date(Number.isInteger(t)?t:Date.parse(t));return"Invalid Date"!==e.toString()&&(t=e),t},validate(t){t instanceof Date||this.throwError(u.Date.settings.typeError,{value:t})}},Function:{settings:{typeError:"Invalid function"},validate(t){"function"!=typeof t&&this.throwError(u.Function.settings.typeError,{value:t})}},Map:{settings:{typeError:"Invalid map",autoCast:!0},cast:t=>("object"!=typeof t||Array.isArray(t)||t instanceof Map||(t=new Map(Object.entries(t))),t),validate(t){t instanceof Map||this.throwError(u.Map.settings.typeError,{value:t})}},Number:{settings:{typeError:"Invalid number",minError:"minimum accepted value is { value }",maxError:"maximum accepted value is { value }",integerError:"Invalid integer",min:void 0,max:void 0,integer:!1,decimalPlaces:void 0,autoCast:!1},cast:t=>Number(t),validate(t){("number"!=typeof t||isNaN(t))&&this.throwError(u.Number.settings.typeError,{value:t}),this.settings.integer&&!Number.isInteger(t)&&this.throwError(u.Number.settings.integerError,{value:t}),void 0!==this.settings.min&&t<this.settings.min&&this.throwError(u.Number.settings.minError,{value:this.settings.min}),void 0!==this.settings.max&&t>this.settings.max&&this.throwError(u.Number.settings.maxError,{value:this.settings.max})},parse(t){if(void 0!==this.settings.decimalPlaces){const e=Math.pow(10,this.settings.decimalPlaces);return Math.round(t*e)/e}return t}},Object:{settings:{typeError:"Invalid object"},parse(t){return void 0!==this.settings.mapSchema&&Object.keys(t).forEach(e=>{const s=t[e],r=this.constructor.castSchema(this.settings.mapSchema),i="Schema"===this.constructor.guessType(r)?this.constructor.cloneSchema({schema:r,name:e,settings:r.settings,parent:this}):t[e]=new this.constructor(this.settings.mapSchema,Object.assign({},this.settings.mapSchema,{name:e,parent:this}));t[e]=i.parse(s)}),t},validate(t){"object"!=typeof t&&this.throwError(u.Object.settings.typeError,{value:t})}},Promise:{settings:{typeError:"Invalid Promise",autoCast:!1,isPromise:t=>"object"==typeof t&&"function"==typeof t.then},cast:t=>u.Promise.settings.isPromise(t)?t:"function"==typeof t?Promise.resolve(t()):Promise.resolve(t),validate(t){u.Promise.settings.isPromise(t)||this.throwError(u.Promise.settings.typeError,{value:t})}},Set:{settings:{typeError:"Invalid set",autoCast:!0},cast:t=>(Array.isArray(t)&&(t=new Set(t)),t),validate(t){t instanceof Set||this.throwError(u.Set.settings.typeError,{value:t})}},String:{settings:{typeError:"Invalid string",enumError:"Unknown enum option { value }",enum:[],autoCast:!1,lowercase:!1,uppercase:!1},cast:t=>(t&&Object.hasOwnProperty.call(t,"toString")&&"function"==typeof t.toString&&"[object Object]"!==t.toString()&&(t=t.toString()),t),validate(t){if("string"!=typeof t&&this.throwError(u.String.settings.typeError,{value:t}),Array.isArray(this.settings.enum)&&this.settings.enum.length>0&&this.settings.enum.indexOf(t)<0&&this.throwError(u.String.settings.enumError,{value:t}),this.settings.minlength){const[e,s]=c(this.settings.minlength,"Invalid minlength");t.length<e&&this.throwError(s,{value:t})}if(this.settings.maxlength){const[e,s]=c(this.settings.maxlength,"Invalid maxlength");t.length>e&&this.throwError(s,{value:t})}if(this.settings.regex){const[e,s]=c(this.settings.regex,"Invalid regex");e.test(t)||this.throwError(s,{value:t})}},parse(t){return this.settings.lowercase&&(t=t.toLowerCase()),this.settings.uppercase&&(t=t.toUpperCase()),t}}};class p extends Error{constructor(t,{errors:e=[],value:s,field:r}){super(n(t,{errors:e,value:s,field:r})),this.errors=e,this.value=s,this.field=r}toJSON(){const{message:t,value:e}=this,s={message:t,value:e};return this.field&&Object.assign(s,{field:this.field.fullPath}),s}}const g=t=>t;class d{constructor(t,{name:s,defaultValues:r={},parent:i,validate:a,cast:n,settings:o={}}={}){if(this._settings=o,Array.isArray(t)&&1===t.length&&(t=t[0]),this.schema=t,this.parent=i,this._validate=a,this._cast=n,this.name=s||"",this.originalName=this.name,this.type=d.guessType(t),this.currentType=e(this.type)[0],this.children=[],this._defaultSettings={required:!0,allowNull:!1,default:void 0},this._defaultValues=r,this.virtuals=[],d.isNested(t)?this.children=this._parseSchema(t):(this._settings="object"==typeof t?Object.assign({},this._settings,{required:void 0===t.default},t):this._settings,delete this._settings.type),void 0!==this.settings.default&&this.settings.required)throw new Error(`Remove either the 'required' or the 'default' option for property ${this.fullPath}.`);this._defaultSettings.default=this.getDefault()}get hasChildren(){return this.children.length>0}get validate(){return this._validate||g}get cast(){return this._cast||g}get settings(){return!this.hasChildren&&u[this.currentType]&&u[this.currentType].settings?Object.assign(this._defaultSettings,u[this.currentType].settings,this._settings):Object.assign(this._defaultSettings,this._settings)}static castSchema(t){return t instanceof d?t:"object"==typeof t&&"Schema"===d.guessType(t.type)?t.type:t}static castSettings(t){if(t instanceof d)return t.settings;const e=Object.assign({},t);return delete e.type,e}isValid(t){try{return this.parse(t),!0}catch(t){return!1}}_parseSchema(t){return Object.keys(t).map(e=>{const s=Object.getOwnPropertyDescriptor(t,e);if("function"!=typeof s.get&&"function"!=typeof s.set)return"Schema"===d.guessType(t[e])?d.cloneSchema({schema:d.castSchema(t[e]),settings:d.castSettings(t[e]),name:e,parent:this}):new d(t[e],{name:e,parent:this});this.virtuals.push({path:e,getter:s.get,setter:s.set})}).filter(Boolean)}static isNested(t){return"Object"===d.guessType(t)&&!t.type}static guessType(t){return t instanceof d?"Schema":"function"==typeof t?t.name:"object"==typeof t&&t.type?d.guessType(t.type):"object"!=typeof t||Array.isArray(t)?(Array.isArray(t)&&(t=t.map(d.guessType)),t):"Object"}get fullPath(){return(this.parent&&this.parent.fullPath?this.parent.fullPath+".":"")+this.name}get ownPaths(){return this.children.map(({name:t})=>t)}get paths(){const t=[];return this.name&&t.push(this.name),this.hasChildren&&this.children.forEach(({paths:e})=>{e.forEach(e=>{t.push((this.name?this.name+".":"")+e)})}),t}static cloneSchema({schema:t,name:e,parent:s,settings:r={},defaultValues:i}){const a=Object.assign(Object.create(Object.getPrototypeOf(t)),t,{name:e||t.name,parent:s,cloned:!0,_defaultValues:i||t._defaulValues,_settings:Object.assign({},t._settings,r)});return a.children&&(a.children=a.children.map(t=>d.cloneSchema({schema:t,parent:a}))),a}schemaAtPath(t){const[e,s]=t.split(/\./);let r;return i(this.children,t=>{if(t.name===e)return r=t,!1}),s?r.schemaAtPath(s):r}hasField(t,e=!1){return this.paths.indexOf(e?t:t.replace(/\..*$/,""))>=0}structureValidation(t){if(!o(t)||!this.hasChildren)return;const e=[];if(h(t,this.ownPaths)||t&&s(t).forEach(t=>{this.hasChildren&&!this.hasField(t)&&e.push(new Error(`Unknown property ${this.name?this.name+".":""}${t}`))}),this.ownPaths.forEach(s=>{try{this.schemaAtPath(s).structureValidation(t[s])}catch(t){const{errors:s}=t;e.push(...s)}}),e.length>0)throw new p("Invalid object schema"+(this.parent?" in property "+this.fullPath:""),{errors:e,value:t,field:this})}fullCast(t,{state:e}){return"object"==typeof(t=this.cast(t,{state:e}))&&t&&this.hasChildren&&this.children.forEach(s=>{void 0!==s.fullCast(t[s.name],{state:e})&&(t[s.name]=s.fullCast(t[s.name],{state:e}))}),t}parse(t,{state:e={}}={}){return t=this.fullCast(t,{state:e}),this.parent||this.structureValidation(t),t=this.hasChildren?this.runChildren(t,{state:e}):this.parseProperty(this.type,t,{state:e}),this.validate(t,{state:e}),o(t)&&this.virtuals.forEach(({path:e,getter:s,setter:r})=>{Object.defineProperties(t,{[e]:{get:s,set:r}})}),t}processLoaders(t,{loaders:s,state:r}){return i(e(s),e=>{"object"!=typeof e&&(e={type:e});const s=d.guessType(e),i=Object.assign(Object.create(this),this,{type:s,_cast:void 0,_validate:void 0});"Schema"!==s&&(i._settings=Object.assign({},i._settings,e,{loaders:void 0,cast:void 0,validate:void 0})),t=i.parseProperty(s,t,{state:r})}),t}parseProperty(t,e,{state:s={}}={}){if(null===e&&this.settings.allowNull)return e;if(Array.isArray(t)){let r,a=!1;return i(t,t=>{try{return this.currentType=t,r=this.parseProperty(t,e,{state:s}),a=!0,!1}catch(t){}}),a||this.throwError(`Could not resolve given value type${this.fullPath?" in property "+this.fullPath:""}. Allowed types are ${t.slice(0,-1).join(", ")+" and "+t.pop()}`,{value:e}),r}const r=u[t];if(r||this.throwError(`Don't know how to resolve ${t} in property ${this.fullPath}`,{value:e}),void 0!==this.settings.default&&void 0===e&&(e="function"==typeof this.settings.default?this.settings.default.call(this,{state:s}):this.settings.default),void 0!==e||this.settings.required){if(void 0===e&&this.settings.required){const[t,s]=c(this.settings.required,`Property ${this.fullPath} is required`);t&&this.throwError(s,{value:e})}return this.settings.loaders&&(e=this.processLoaders(e,{loaders:this.settings.loaders,state:s})),r.loaders&&(e=this.processLoaders(e,{loaders:r.loaders,state:s})),e=this.runTransformer({method:"cast",transformer:this.settings,payload:e,state:s}),this.settings.autoCast&&(e=this.runTransformer({method:"cast",transformer:r,payload:e,state:s})),this.runTransformer({method:"validate",transformer:r,payload:e,state:s}),this.runTransformer({method:"validate",transformer:this.settings,payload:e,state:s}),this.runTransformer({method:"parse",transformer:r,payload:e,state:s})}}runChildren(t,{method:e="parse",state:s={}}={}){if(!this.settings.required&&void 0===t)return;const r={},i=[];if(this.ownPaths.forEach(a=>{const n=this.schemaAtPath(a.replace(/\..*$/)),h=o(t)?t[n.name]:void 0;(t=>{try{t()}catch(t){t instanceof p&&t instanceof p&&t.errors.length>0?i.push(...t.errors):i.push(t)}})(()=>{const t=n[e](h,{state:s});void 0!==t&&Object.assign(r,{[n.name]:t})})}),i.length>0)throw new p("Data is not valid",{errors:i});return r}runTransformer({method:t,transformer:e,payload:s,state:r}){return e[t]?e[t].call(this,s,{state:r}):s}throwError(t,{errors:e,value:s}={}){throw new p(t,{errors:e,value:s,field:this})}getDefault(t){return this.parent?this.parent.getDefault(t?`${this.name}.${t}`:this.name):t?r(this._defaultValues,t):void 0}}t.Schema=d,t.Transformers=u,t.Utils=l,t.ValidationError=p,Object.defineProperty(t,"__esModule",{value:!0})}));
